<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Space Defender</title>
    <link rel="shortcut icon" href="images/logo.png" type="image/x-icon">

    <meta name="application-name" content="Inbondz">
     <!-- auto ads  -->
     <!-- <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2280832801216201"
     crossorigin="anonymous"></script> -->
    <!-- auto ads end  -->
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* Prevent mobile scrolling */
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            background: linear-gradient(to bottom, #000000, #0a0a1a);
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            pointer-events: none;
            z-index: 10;
        }

        .score-label {
            font-size: 14px;
            color: #00ffff;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #score {
            font-size: 32px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ffff;
        }

        /* Powerup Status Indicator */
        #status-display {
            margin-top: 10px;
            font-size: 14px;
            font-weight: bold;
            letter-spacing: 1px;
            height: 20px; /* Reserve space */
        }
        
        .status-spread { color: #00ff00; text-shadow: 0 0 5px #00ff00; }
        .status-rapid { color: #ffaa00; text-shadow: 0 0 5px #ffaa00; }
        .status-normal { color: #555; }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 20;
            backdrop-filter: blur(5px);
        }

        h1 {
            font-size: 4rem;
            margin: 0;
            background: linear-gradient(45deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            text-align: center;
        }

        p {
            font-size: 1.2rem;
            color: #aaa;
            margin-bottom: 30px;
            text-align: center;
            max-width: 600px;
            padding: 0 20px;
        }

        button {
            padding: 15px 40px;
            font-size: 1.5rem;
            background: transparent;
            color: #fff;
            border: 2px solid #00ffff;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
        }

        button:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.6);
            transform: scale(1.05);
        }

        .hidden {
            display: none !important;
        }
        
        /* Mobile controls hint */
        .controls-hint {
            margin-top: 20px;
            font-size: 0.9rem;
            opacity: 0.7;
        }
    </style>
</head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1605V9LS1K"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1605V9LS1K');
</script>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div class="score-label">Score</div>
        <div id="score">0</div>
        <div id="status-display" class="status-normal">SYSTEM: NORMAL</div>
    </div>

    <div id="start-screen">
        <h1>NEON DEFENDER</h1>
        <p>Defend the core. Collect Orbs for Powerups.</p>
        <button id="start-btn">Start Mission</button>
        <div class="controls-hint">Desktop: Arrow Keys + Space + Enter | Mobile: Touch & Drag</div>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1>SYSTEM FAILURE</h1>
        <p>Your final score: <span id="final-score">0</span></p>
        <button id="restart-btn">Reboot System</button>
        <div class="controls-hint">Press Enter or Tap Screen to Reboot</div>
    </div>
</div>

<script>
    /**
     * NEON SPACE DEFENDER
     * Features: Fast Paced, Power-ups (Spread/Rapid), Particles
     */

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const statusEl = document.getElementById('status-display');
    const finalScoreEl = document.getElementById('final-score');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const startBtn = document.getElementById('start-btn');
    const restartBtn = document.getElementById('restart-btn');

    // Game State
    let animationId = null;
    let gameRunning = false;
    let score = 0;
    let frames = 0;
    let difficultyMultiplier = 1;

    // Entities
    let player;
    let projectiles = [];
    let enemies = [];
    let particles = [];
    let stars = [];
    let powerUps = []; // Array for collectible items

    // Input State
    const keys = {
        ArrowUp: false,
        ArrowDown: false,
        ArrowLeft: false,
        ArrowRight: false,
        Space: false
    };

    // Responsive Canvas Sizing
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        if (stars.length === 0 || stars.length < 50) {
            initStars();
        }
    }
    window.addEventListener('resize', resizeCanvas);

    // --- CLASSES ---

    class Star {
        constructor() {
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height;
            this.size = Math.random() * 2.5 + 0.5;
            this.speed = Math.random() * 0.5 + 0.2; 
            this.opacity = Math.random() * 0.5 + 0.3;
        }

        update() {
            this.y += this.speed * (gameRunning ? 2 : 0.5);
            if (this.y > canvas.height) {
                this.y = 0;
                this.x = Math.random() * canvas.width;
            }
        }

        draw() {
            ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    class Player {
        constructor() {
            this.width = 40;
            this.height = 50;
            this.x = canvas.width / 2 - this.width / 2;
            this.y = canvas.height - 100;
            this.color = '#00ffff';
            this.speed = 7;
            this.lastShot = 0;
            // UPDATE: Base shoot delay decreased from 15 to 8 (Faster Fire)
            this.baseShootDelay = 8; 
            
            // Powerup properties
            this.powerUpType = 'none';
            this.powerUpTimer = 0;
        }

        activatePowerUp(type) {
            this.powerUpType = type;
            this.powerUpTimer = 500; // Duration in frames (approx 8 seconds)
            
            // UI Update
            if (type === 'spread') {
                statusEl.textContent = "SYSTEM: SPREAD SHOT";
                statusEl.className = "status-spread";
            } else if (type === 'rapid') {
                statusEl.textContent = "SYSTEM: RAPID FIRE";
                statusEl.className = "status-rapid";
            }
        }

        update() {
            // Movement
            if (keys.ArrowLeft && this.x > 0) this.x -= this.speed;
            if (keys.ArrowRight && this.x < canvas.width - this.width) this.x += this.speed;
            if (keys.ArrowUp && this.y > 0) this.y -= this.speed;
            if (keys.ArrowDown && this.y < canvas.height - this.height) this.y += this.speed;

            // Handle Powerup Timer
            if (this.powerUpTimer > 0) {
                this.powerUpTimer--;
                if (this.powerUpTimer <= 0) {
                    this.powerUpType = 'none';
                    statusEl.textContent = "SYSTEM: NORMAL";
                    statusEl.className = "status-normal";
                }
            }

            // Determine effective fire rate
            let currentDelay = this.baseShootDelay;
            if (this.powerUpType === 'rapid') currentDelay = 4; // Insanely fast

            // Shooting
            if (keys.Space || isTouching) { 
                if (frames - this.lastShot > currentDelay) {
                    this.shoot();
                    this.lastShot = frames;
                }
            }
        }

        draw() {
            ctx.save();
            ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
            
            // Glow effect changes based on powerup
            ctx.shadowBlur = 15;
            if (this.powerUpType === 'spread') ctx.shadowColor = '#00ff00';
            else if (this.powerUpType === 'rapid') ctx.shadowColor = '#ffaa00';
            else ctx.shadowColor = this.color;

            // Draw Ship
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.moveTo(0, -this.height / 2);
            ctx.lineTo(-this.width / 2, this.height / 2);
            ctx.lineTo(0, this.height / 2 - 10);
            ctx.lineTo(this.width / 2, this.height / 2);
            ctx.closePath();
            ctx.fill();

            // Engine flame
            if (gameRunning) {
                ctx.fillStyle = `rgba(255, 100, 0, ${Math.random() * 0.5 + 0.5})`;
                ctx.beginPath();
                ctx.moveTo(-5, this.height / 2 - 5);
                ctx.lineTo(5, this.height / 2 - 5);
                ctx.lineTo(0, this.height / 2 + Math.random() * 20 + 10);
                ctx.fill();
            }

            ctx.restore();
        }

        shoot() {
            if (this.powerUpType === 'spread') {
                // 3 Bullets: Center, Left diagonal, Right diagonal
                projectiles.push(new Projectile(this.x + this.width / 2, this.y, 0));
                projectiles.push(new Projectile(this.x + this.width / 2, this.y, -2));
                projectiles.push(new Projectile(this.x + this.width / 2, this.y, 2));
            } else {
                // Normal Shot
                projectiles.push(new Projectile(this.x + this.width / 2, this.y, 0));
            }
        }
    }

    class Projectile {
        constructor(x, y, vx = 0) { // Added horizontal velocity (vx)
            this.x = x;
            this.y = y;
            this.vx = vx;
            this.radius = 4;
            this.speed = 12;
            this.color = '#ffff00';
            this.markedForDeletion = false;
        }

        update() {
            this.y -= this.speed;
            this.x += this.vx; // Move sideways if needed
            
            // Delete if off screen (top, left, or right)
            if (this.y < 0 || this.x < 0 || this.x > canvas.width) {
                this.markedForDeletion = true;
            }
        }

        draw() {
            ctx.save();
            ctx.shadowBlur = 10;
            ctx.shadowColor = this.color;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    }

    class PowerUp {
        constructor() {
            this.radius = 15;
            this.x = Math.random() * (canvas.width - this.radius * 2) + this.radius;
            this.y = -this.radius;
            this.speed = 3;
            // 50/50 chance for Type
            this.type = Math.random() > 0.5 ? 'spread' : 'rapid';
            this.color = this.type === 'spread' ? '#00ff00' : '#ffaa00';
            this.letter = this.type === 'spread' ? 'S' : 'R';
            this.markedForDeletion = false;
            this.pulse = 0;
        }

        update() {
            this.y += this.speed;
            this.pulse += 0.1;
            if (this.y > canvas.height + this.radius) {
                this.markedForDeletion = true;
            }
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            
            // Pulsing animation
            const scale = 1 + Math.sin(this.pulse) * 0.1;
            ctx.scale(scale, scale);

            // Outer Glow
            ctx.shadowBlur = 20;
            ctx.shadowColor = this.color;
            
            // Orb body
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fill();

            // Letter
            ctx.fillStyle = 'black';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.letter, 0, 1); // +1 y for visual centering

            ctx.restore();
        }
    }

    class Enemy {
        constructor() {
            this.radius = Math.random() * 15 + 15;
            this.x = Math.random() * (canvas.width - this.radius * 2) + this.radius;
            this.y = -this.radius; 
            this.speed = Math.random() * 2 + 1 + (difficultyMultiplier * 0.5);
            this.color = `hsl(${Math.random() * 60 + 300}, 100%, 50%)`; 
            this.markedForDeletion = false;
            this.angle = 0;
            this.spinSpeed = Math.random() * 0.1 - 0.05;
            this.points = 100 + Math.floor(50 - this.radius);
            if (this.points < 10) this.points = 10;
        }

        update() {
            this.y += this.speed;
            this.angle += this.spinSpeed;
            if (this.y > canvas.height + this.radius) {
                this.markedForDeletion = true;
            }
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);
            ctx.shadowBlur = 10;
            ctx.shadowColor = this.color;
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 3;

            ctx.beginPath();
            const sides = 6;
            for (let i = 0; i < sides; i++) {
                const rot = (Math.PI * 2 / sides) * i;
                const px = Math.cos(rot) * this.radius;
                const py = Math.sin(rot) * this.radius;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.stroke();

            ctx.fillStyle = this.color;
            ctx.globalAlpha = 0.3;
            ctx.fill();
            
            ctx.restore();
        }
    }

    class Particle {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.radius = Math.random() * 3 + 1;
            this.speedX = Math.random() * 6 - 3;
            this.speedY = Math.random() * 6 - 3;
            this.color = color;
            this.alpha = 1;
            this.decay = 0.02; 
        }

        update() {
            this.x += this.speedX;
            this.y += this.speedY;
            this.alpha -= this.decay;
        }

        draw() {
            ctx.save();
            ctx.globalAlpha = this.alpha;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    }

    // --- GAME LOGIC ---

    function initStars() {
        stars = [];
        for (let i = 0; i < 150; i++) {
            stars.push(new Star());
        }
    }

    function spawnEnemy() {
        let spawnRate = 60; 
        if (score > 1000) spawnRate = 45;
        if (score > 2000) spawnRate = 30;
        if (score > 5000) spawnRate = 20;

        if (frames % spawnRate === 0) {
            enemies.push(new Enemy());
        }
    }

    function spawnPowerUp() {
        // Random chance to spawn powerup (approx every 10 seconds)
        if (Math.random() < 0.0015) {
            powerUps.push(new PowerUp());
        }
    }

    function createExplosion(x, y, color) {
        for (let i = 0; i < 15; i++) {
            particles.push(new Particle(x, y, color));
        }
    }

    function checkCollisions() {
        // 1. Projectiles vs Enemies
        projectiles.forEach((proj) => {
            if (proj.markedForDeletion) return;

            enemies.forEach((enemy) => {
                if (enemy.markedForDeletion || proj.markedForDeletion) return;

                const dist = Math.hypot(proj.x - enemy.x, proj.y - enemy.y);
                
                if (dist - enemy.radius - proj.radius < 1) {
                    createExplosion(enemy.x, enemy.y, enemy.color);
                    score += enemy.points;
                    scoreEl.textContent = score;

                    enemy.markedForDeletion = true;
                    proj.markedForDeletion = true;
                }
            });
        });

        // 2. PowerUps vs Player
        powerUps.forEach(powerUp => {
            if (powerUp.markedForDeletion) return;

            const dist = Math.hypot(player.x + player.width/2 - powerUp.x, player.y + player.height/2 - powerUp.y);
            
            // Collision radius
            if (dist - powerUp.radius - 20 < 1) {
                // Activate Powerup
                player.activatePowerUp(powerUp.type);
                powerUp.markedForDeletion = true;
                // Add tiny particle effect for pickup
                createExplosion(powerUp.x, powerUp.y, powerUp.color);
            }
        });

        // 3. Enemies vs Player
        enemies.forEach(enemy => {
            if (enemy.markedForDeletion) return;
            
            const dist = Math.hypot(player.x + player.width/2 - enemy.x, player.y + player.height/2 - enemy.y);
            
            if (dist - enemy.radius - 20 < 1) {
                createExplosion(player.x + player.width/2, player.y + player.height/2, '#00ffff');
                endGame();
            }
        });
    }

    function processParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            const particle = particles[i];
            particle.update();
            particle.draw();
            if (particle.alpha <= 0) particles.splice(i, 1);
        }
    }

    function update() {
        if (!gameRunning) {
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            stars.forEach(star => { star.update(); star.draw(); });
            processParticles();
            animationId = requestAnimationFrame(update);
            return;
        }

        ctx.fillStyle = 'rgba(5, 5, 5, 0.4)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        frames++;
        difficultyMultiplier = 1 + (score / 5000);

        // Background
        stars.forEach(star => { star.update(); star.draw(); });

        // Player
        player.update();
        player.draw();

        // Projectiles
        for (let i = projectiles.length - 1; i >= 0; i--) {
            const proj = projectiles[i];
            proj.update();
            if (!proj.markedForDeletion) proj.draw();
            if (proj.markedForDeletion) projectiles.splice(i, 1);
        }

        // Enemies
        for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i];
            enemy.update();
            if (!enemy.markedForDeletion) enemy.draw();
            if (enemy.markedForDeletion) enemies.splice(i, 1);
        }

        // PowerUps
        for (let i = powerUps.length - 1; i >= 0; i--) {
            const pu = powerUps[i];
            pu.update();
            if (!pu.markedForDeletion) pu.draw();
            if (pu.markedForDeletion) powerUps.splice(i, 1);
        }

        spawnEnemy();
        spawnPowerUp();
        processParticles();
        checkCollisions();

        animationId = requestAnimationFrame(update);
    }

    function initGame() {
        if (animationId) cancelAnimationFrame(animationId);

        resizeCanvas();
        player = new Player();
        projectiles = [];
        enemies = [];
        particles = [];
        powerUps = []; // Reset Powerups
        score = 0;
        frames = 0;
        scoreEl.textContent = '0';
        statusEl.textContent = "SYSTEM: NORMAL";
        statusEl.className = "status-normal";
        gameRunning = true;
        
        startScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
        
        update();
    }

    function endGame() {
        gameRunning = false;
        finalScoreEl.textContent = score;
        gameOverScreen.classList.remove('hidden');
    }

    // --- INPUT LISTENERS ---

    window.addEventListener('keydown', e => {
        if (e.code === 'ArrowUp') keys.ArrowUp = true;
        if (e.code === 'ArrowDown') keys.ArrowDown = true;
        if (e.code === 'ArrowLeft') keys.ArrowLeft = true;
        if (e.code === 'ArrowRight') keys.ArrowRight = true;
        if (e.code === 'Space') keys.Space = true;

        if (e.code === 'Enter' && !gameRunning) triggerGameStart();
    });

    window.addEventListener('keyup', e => {
        if (e.code === 'ArrowUp') keys.ArrowUp = false;
        if (e.code === 'ArrowDown') keys.ArrowDown = false;
        if (e.code === 'ArrowLeft') keys.ArrowLeft = false;
        if (e.code === 'ArrowRight') keys.ArrowRight = false;
        if (e.code === 'Space') keys.Space = false;
    });

    // Touch Support
    let isTouching = false;
    
    window.addEventListener('touchstart', e => {
        if (gameRunning) { isTouching = true; handleTouch(e); }
    }, {passive: false});

    window.addEventListener('touchmove', e => {
        if (gameRunning) { e.preventDefault(); handleTouch(e); }
    }, {passive: false});

    window.addEventListener('touchend', () => { isTouching = false; });

    function handleTouch(e) {
        if (!gameRunning || !player) return;
        const touch = e.touches[0];
        player.x = touch.clientX - player.width / 2;
        player.y = touch.clientY - player.height - 50; 
        
        if (player.x < 0) player.x = 0;
        if (player.x > canvas.width - player.width) player.x = canvas.width - player.width;
        if (player.y < 0) player.y = 0;
        if (player.y > canvas.height - player.height) player.y = canvas.height - player.height;
    }

    function triggerGameStart() {
        if (!gameRunning) {
            if (frames === 0) initStars(); 
            initGame();
        }
    }

    startBtn.addEventListener('click', (e) => { e.stopPropagation(); triggerGameStart(); });
    restartBtn.addEventListener('click', (e) => { e.stopPropagation(); triggerGameStart(); });
    startScreen.addEventListener('click', triggerGameStart);
    gameOverScreen.addEventListener('click', triggerGameStart);

    // Initial render
    resizeCanvas();
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    update();

</script>
</body>
</html>